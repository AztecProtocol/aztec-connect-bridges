/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace AztecTypes {
  export type AztecAssetStruct = {
    id: PromiseOrValue<BigNumberish>;
    erc20Address: PromiseOrValue<string>;
    assetType: PromiseOrValue<BigNumberish>;
  };

  export type AztecAssetStructOutput = [BigNumber, string, number] & {
    id: BigNumber;
    erc20Address: string;
    assetType: number;
  };
}

export declare namespace BiDCABridge {
  export type DCAStruct = {
    amount: PromiseOrValue<BigNumberish>;
    start: PromiseOrValue<BigNumberish>;
    end: PromiseOrValue<BigNumberish>;
    aToB: PromiseOrValue<boolean>;
  };

  export type DCAStructOutput = [BigNumber, number, number, boolean] & {
    amount: BigNumber;
    start: number;
    end: number;
    aToB: boolean;
  };

  export type SubTickStruct = {
    sold: PromiseOrValue<BigNumberish>;
    bought: PromiseOrValue<BigNumberish>;
  };

  export type SubTickStructOutput = [BigNumber, BigNumber] & {
    sold: BigNumber;
    bought: BigNumber;
  };

  export type TickStruct = {
    availableA: PromiseOrValue<BigNumberish>;
    availableB: PromiseOrValue<BigNumberish>;
    poke: PromiseOrValue<BigNumberish>;
    aToBSubTick: BiDCABridge.SubTickStruct;
    bToASubTick: BiDCABridge.SubTickStruct;
    priceOfAInB: PromiseOrValue<BigNumberish>;
    priceTime: PromiseOrValue<BigNumberish>;
  };

  export type TickStructOutput = [
    BigNumber,
    BigNumber,
    number,
    BiDCABridge.SubTickStructOutput,
    BiDCABridge.SubTickStructOutput,
    BigNumber,
    number
  ] & {
    availableA: BigNumber;
    availableB: BigNumber;
    poke: number;
    aToBSubTick: BiDCABridge.SubTickStructOutput;
    bToASubTick: BiDCABridge.SubTickStructOutput;
    priceOfAInB: BigNumber;
    priceTime: number;
  };
}

export interface UniswapDCABridgeInterface extends utils.Interface {
  functions: {
    "ASSET_A()": FunctionFragment;
    "ASSET_B()": FunctionFragment;
    "FEE()": FunctionFragment;
    "FEE_DIVISOR()": FunctionFragment;
    "ORACLE()": FunctionFragment;
    "ROLLUP_PROCESSOR()": FunctionFragment;
    "SLIPPAGE()": FunctionFragment;
    "SUBSIDY()": FunctionFragment;
    "TICK_SIZE()": FunctionFragment;
    "UNI_ROUTER()": FunctionFragment;
    "computeCriteria((uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),uint64)": FunctionFragment;
    "convert((uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),uint256,uint256,uint64,address)": FunctionFragment;
    "dcas(uint256)": FunctionFragment;
    "denominateAssetAInB(uint256,uint256,bool)": FunctionFragment;
    "denominateAssetBInA(uint256,uint256,bool)": FunctionFragment;
    "earliestTickWithAvailableA()": FunctionFragment;
    "earliestTickWithAvailableB()": FunctionFragment;
    "finalise((uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),(uint256,address,uint8),uint256,uint64)": FunctionFragment;
    "getAccumulated(uint256)": FunctionFragment;
    "getAvailable()": FunctionFragment;
    "getDCA(uint256)": FunctionFragment;
    "getPrice()": FunctionFragment;
    "getTick(uint256)": FunctionFragment;
    "pokeNextTicks(uint256)": FunctionFragment;
    "pokeTicks(uint256,uint256)": FunctionFragment;
    "rebalanceAndFill(uint256,uint256,uint256)": FunctionFragment;
    "rebalanceAndFill(uint256,uint256)": FunctionFragment;
    "rebalanceAndFillUniswap(uint256)": FunctionFragment;
    "rebalanceAndFillUniswap()": FunctionFragment;
    "ticks(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ASSET_A"
      | "ASSET_B"
      | "FEE"
      | "FEE_DIVISOR"
      | "ORACLE"
      | "ROLLUP_PROCESSOR"
      | "SLIPPAGE"
      | "SUBSIDY"
      | "TICK_SIZE"
      | "UNI_ROUTER"
      | "computeCriteria"
      | "convert"
      | "dcas"
      | "denominateAssetAInB"
      | "denominateAssetBInA"
      | "earliestTickWithAvailableA"
      | "earliestTickWithAvailableB"
      | "finalise"
      | "getAccumulated"
      | "getAvailable"
      | "getDCA"
      | "getPrice"
      | "getTick"
      | "pokeNextTicks"
      | "pokeTicks"
      | "rebalanceAndFill(uint256,uint256,uint256)"
      | "rebalanceAndFill(uint256,uint256)"
      | "rebalanceAndFillUniswap(uint256)"
      | "rebalanceAndFillUniswap()"
      | "ticks"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "ASSET_A", values?: undefined): string;
  encodeFunctionData(functionFragment: "ASSET_B", values?: undefined): string;
  encodeFunctionData(functionFragment: "FEE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "FEE_DIVISOR",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "ORACLE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ROLLUP_PROCESSOR",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "SLIPPAGE", values?: undefined): string;
  encodeFunctionData(functionFragment: "SUBSIDY", values?: undefined): string;
  encodeFunctionData(functionFragment: "TICK_SIZE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "UNI_ROUTER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "computeCriteria",
    values: [
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "convert",
    values: [
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "dcas",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "denominateAssetAInB",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "denominateAssetBInA",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "earliestTickWithAvailableA",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "earliestTickWithAvailableB",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "finalise",
    values: [
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      AztecTypes.AztecAssetStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccumulated",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAvailable",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDCA",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getPrice", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getTick",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "pokeNextTicks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "pokeTicks",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceAndFill(uint256,uint256,uint256)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceAndFill(uint256,uint256)",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceAndFillUniswap(uint256)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceAndFillUniswap()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ticks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "ASSET_A", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ASSET_B", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "FEE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "FEE_DIVISOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ORACLE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ROLLUP_PROCESSOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "SLIPPAGE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "SUBSIDY", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "TICK_SIZE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "UNI_ROUTER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "computeCriteria",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "convert", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dcas", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "denominateAssetAInB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "denominateAssetBInA",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "earliestTickWithAvailableA",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "earliestTickWithAvailableB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finalise", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAccumulated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAvailable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDCA", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getTick", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pokeNextTicks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pokeTicks", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceAndFill(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceAndFill(uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceAndFillUniswap(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceAndFillUniswap()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ticks", data: BytesLike): Result;

  events: {};
}

export interface UniswapDCABridge extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: UniswapDCABridgeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ASSET_A(overrides?: CallOverrides): Promise<[string]>;

    ASSET_B(overrides?: CallOverrides): Promise<[string]>;

    FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    FEE_DIVISOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    ORACLE(overrides?: CallOverrides): Promise<[string]>;

    ROLLUP_PROCESSOR(overrides?: CallOverrides): Promise<[string]>;

    SLIPPAGE(overrides?: CallOverrides): Promise<[BigNumber]>;

    SUBSIDY(overrides?: CallOverrides): Promise<[string]>;

    TICK_SIZE(overrides?: CallOverrides): Promise<[BigNumber]>;

    UNI_ROUTER(overrides?: CallOverrides): Promise<[string]>;

    computeCriteria(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      arg2: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      arg4: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    convert(
      _inputAssetA: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _inputValue: PromiseOrValue<BigNumberish>,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      arg7: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dcas(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, boolean] & {
        amount: BigNumber;
        start: number;
        end: number;
        aToB: boolean;
      }
    >;

    denominateAssetAInB(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    denominateAssetBInA(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    earliestTickWithAvailableA(overrides?: CallOverrides): Promise<[number]>;

    earliestTickWithAvailableB(overrides?: CallOverrides): Promise<[number]>;

    finalise(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAccumulated(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { accumulated: BigNumber; ready: boolean }
    >;

    getAvailable(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { availableA: BigNumber; availableB: BigNumber }
    >;

    getDCA(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BiDCABridge.DCAStructOutput]>;

    getPrice(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getTick(
      _tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BiDCABridge.TickStructOutput]>;

    pokeNextTicks(
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pokeTicks(
      _startTick: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "rebalanceAndFill(uint256,uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "rebalanceAndFill(uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "rebalanceAndFillUniswap(uint256)"(
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "rebalanceAndFillUniswap()"(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    ticks(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        number,
        BiDCABridge.SubTickStructOutput,
        BiDCABridge.SubTickStructOutput,
        BigNumber,
        number
      ] & {
        availableA: BigNumber;
        availableB: BigNumber;
        poke: number;
        aToBSubTick: BiDCABridge.SubTickStructOutput;
        bToASubTick: BiDCABridge.SubTickStructOutput;
        priceOfAInB: BigNumber;
        priceTime: number;
      }
    >;
  };

  ASSET_A(overrides?: CallOverrides): Promise<string>;

  ASSET_B(overrides?: CallOverrides): Promise<string>;

  FEE(overrides?: CallOverrides): Promise<BigNumber>;

  FEE_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

  ORACLE(overrides?: CallOverrides): Promise<string>;

  ROLLUP_PROCESSOR(overrides?: CallOverrides): Promise<string>;

  SLIPPAGE(overrides?: CallOverrides): Promise<BigNumber>;

  SUBSIDY(overrides?: CallOverrides): Promise<string>;

  TICK_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

  UNI_ROUTER(overrides?: CallOverrides): Promise<string>;

  computeCriteria(
    arg0: AztecTypes.AztecAssetStruct,
    arg1: AztecTypes.AztecAssetStruct,
    arg2: AztecTypes.AztecAssetStruct,
    arg3: AztecTypes.AztecAssetStruct,
    arg4: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  convert(
    _inputAssetA: AztecTypes.AztecAssetStruct,
    arg1: AztecTypes.AztecAssetStruct,
    _outputAssetA: AztecTypes.AztecAssetStruct,
    arg3: AztecTypes.AztecAssetStruct,
    _inputValue: PromiseOrValue<BigNumberish>,
    _interactionNonce: PromiseOrValue<BigNumberish>,
    _numTicks: PromiseOrValue<BigNumberish>,
    arg7: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dcas(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, number, boolean] & {
      amount: BigNumber;
      start: number;
      end: number;
      aToB: boolean;
    }
  >;

  denominateAssetAInB(
    _amount: PromiseOrValue<BigNumberish>,
    _priceAToB: PromiseOrValue<BigNumberish>,
    _roundUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  denominateAssetBInA(
    _amount: PromiseOrValue<BigNumberish>,
    _priceAToB: PromiseOrValue<BigNumberish>,
    _roundUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  earliestTickWithAvailableA(overrides?: CallOverrides): Promise<number>;

  earliestTickWithAvailableB(overrides?: CallOverrides): Promise<number>;

  finalise(
    arg0: AztecTypes.AztecAssetStruct,
    arg1: AztecTypes.AztecAssetStruct,
    _outputAssetA: AztecTypes.AztecAssetStruct,
    arg3: AztecTypes.AztecAssetStruct,
    _interactionNonce: PromiseOrValue<BigNumberish>,
    arg5: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAccumulated(
    _nonce: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { accumulated: BigNumber; ready: boolean }>;

  getAvailable(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { availableA: BigNumber; availableB: BigNumber }
  >;

  getDCA(
    _nonce: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BiDCABridge.DCAStructOutput>;

  getPrice(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getTick(
    _tick: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BiDCABridge.TickStructOutput>;

  pokeNextTicks(
    _numTicks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pokeTicks(
    _startTick: PromiseOrValue<BigNumberish>,
    _numTicks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "rebalanceAndFill(uint256,uint256,uint256)"(
    _offerA: PromiseOrValue<BigNumberish>,
    _offerB: PromiseOrValue<BigNumberish>,
    _upperTick: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "rebalanceAndFill(uint256,uint256)"(
    _offerA: PromiseOrValue<BigNumberish>,
    _offerB: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "rebalanceAndFillUniswap(uint256)"(
    _upperTick: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "rebalanceAndFillUniswap()"(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  ticks(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      number,
      BiDCABridge.SubTickStructOutput,
      BiDCABridge.SubTickStructOutput,
      BigNumber,
      number
    ] & {
      availableA: BigNumber;
      availableB: BigNumber;
      poke: number;
      aToBSubTick: BiDCABridge.SubTickStructOutput;
      bToASubTick: BiDCABridge.SubTickStructOutput;
      priceOfAInB: BigNumber;
      priceTime: number;
    }
  >;

  callStatic: {
    ASSET_A(overrides?: CallOverrides): Promise<string>;

    ASSET_B(overrides?: CallOverrides): Promise<string>;

    FEE(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    ORACLE(overrides?: CallOverrides): Promise<string>;

    ROLLUP_PROCESSOR(overrides?: CallOverrides): Promise<string>;

    SLIPPAGE(overrides?: CallOverrides): Promise<BigNumber>;

    SUBSIDY(overrides?: CallOverrides): Promise<string>;

    TICK_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    UNI_ROUTER(overrides?: CallOverrides): Promise<string>;

    computeCriteria(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      arg2: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      arg4: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    convert(
      _inputAssetA: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _inputValue: PromiseOrValue<BigNumberish>,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      arg7: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, boolean]>;

    dcas(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, boolean] & {
        amount: BigNumber;
        start: number;
        end: number;
        aToB: boolean;
      }
    >;

    denominateAssetAInB(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    denominateAssetBInA(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    earliestTickWithAvailableA(overrides?: CallOverrides): Promise<number>;

    earliestTickWithAvailableB(overrides?: CallOverrides): Promise<number>;

    finalise(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        outputValueA: BigNumber;
        interactionComplete: boolean;
      }
    >;

    getAccumulated(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { accumulated: BigNumber; ready: boolean }
    >;

    getAvailable(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { availableA: BigNumber; availableB: BigNumber }
    >;

    getDCA(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BiDCABridge.DCAStructOutput>;

    getPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getTick(
      _tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BiDCABridge.TickStructOutput>;

    pokeNextTicks(
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    pokeTicks(
      _startTick: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "rebalanceAndFill(uint256,uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    "rebalanceAndFill(uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    "rebalanceAndFillUniswap(uint256)"(
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    "rebalanceAndFillUniswap()"(
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    ticks(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        number,
        BiDCABridge.SubTickStructOutput,
        BiDCABridge.SubTickStructOutput,
        BigNumber,
        number
      ] & {
        availableA: BigNumber;
        availableB: BigNumber;
        poke: number;
        aToBSubTick: BiDCABridge.SubTickStructOutput;
        bToASubTick: BiDCABridge.SubTickStructOutput;
        priceOfAInB: BigNumber;
        priceTime: number;
      }
    >;
  };

  filters: {};

  estimateGas: {
    ASSET_A(overrides?: CallOverrides): Promise<BigNumber>;

    ASSET_B(overrides?: CallOverrides): Promise<BigNumber>;

    FEE(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    ORACLE(overrides?: CallOverrides): Promise<BigNumber>;

    ROLLUP_PROCESSOR(overrides?: CallOverrides): Promise<BigNumber>;

    SLIPPAGE(overrides?: CallOverrides): Promise<BigNumber>;

    SUBSIDY(overrides?: CallOverrides): Promise<BigNumber>;

    TICK_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    UNI_ROUTER(overrides?: CallOverrides): Promise<BigNumber>;

    computeCriteria(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      arg2: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      arg4: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    convert(
      _inputAssetA: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _inputValue: PromiseOrValue<BigNumberish>,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      arg7: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dcas(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    denominateAssetAInB(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    denominateAssetBInA(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    earliestTickWithAvailableA(overrides?: CallOverrides): Promise<BigNumber>;

    earliestTickWithAvailableB(overrides?: CallOverrides): Promise<BigNumber>;

    finalise(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAccumulated(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAvailable(overrides?: CallOverrides): Promise<BigNumber>;

    getDCA(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPrice(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getTick(
      _tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    pokeNextTicks(
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pokeTicks(
      _startTick: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "rebalanceAndFill(uint256,uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "rebalanceAndFill(uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "rebalanceAndFillUniswap(uint256)"(
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "rebalanceAndFillUniswap()"(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    ticks(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ASSET_A(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ASSET_B(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_DIVISOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ORACLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ROLLUP_PROCESSOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SLIPPAGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SUBSIDY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TICK_SIZE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UNI_ROUTER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    computeCriteria(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      arg2: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      arg4: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    convert(
      _inputAssetA: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _inputValue: PromiseOrValue<BigNumberish>,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      arg7: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dcas(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    denominateAssetAInB(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    denominateAssetBInA(
      _amount: PromiseOrValue<BigNumberish>,
      _priceAToB: PromiseOrValue<BigNumberish>,
      _roundUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    earliestTickWithAvailableA(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    earliestTickWithAvailableB(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    finalise(
      arg0: AztecTypes.AztecAssetStruct,
      arg1: AztecTypes.AztecAssetStruct,
      _outputAssetA: AztecTypes.AztecAssetStruct,
      arg3: AztecTypes.AztecAssetStruct,
      _interactionNonce: PromiseOrValue<BigNumberish>,
      arg5: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAccumulated(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAvailable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDCA(
      _nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPrice(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getTick(
      _tick: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pokeNextTicks(
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pokeTicks(
      _startTick: PromiseOrValue<BigNumberish>,
      _numTicks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "rebalanceAndFill(uint256,uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "rebalanceAndFill(uint256,uint256)"(
      _offerA: PromiseOrValue<BigNumberish>,
      _offerB: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "rebalanceAndFillUniswap(uint256)"(
      _upperTick: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "rebalanceAndFillUniswap()"(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    ticks(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
